package main

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type GitContext struct {
	GitRoot     string `json:"gitRoot"`
	GitDir      string `json:"gitDir"`
	ExcludePath string `json:"excludePath"`
	RunID       string `json:"runId"`
}

func findGitRoot(start string) string {
	current, err := filepath.Abs(start)
	if err != nil {
		return ""
	}
	for {
		gitPath := filepath.Join(current, ".git")
		if exists(gitPath) {
			return current
		}
		parent := filepath.Dir(current)
		if parent == current {
			return ""
		}
		current = parent
	}
}

func resolveGitDir(gitRoot string) (string, error) {
	gitPath := filepath.Join(gitRoot, ".git")
	info, err := os.Stat(gitPath)
	if err != nil {
		return "", err
	}
	if info.IsDir() {
		return gitPath, nil
	}
	// #nosec G304 -- gitPath is derived from repository root traversal.
	data, err := os.ReadFile(gitPath)
	if err != nil {
		return "", err
	}
	content := strings.TrimSpace(string(data))
	if !strings.HasPrefix(content, "gitdir:") {
		return "", errors.New("unable to resolve git directory")
	}
	gitDir := strings.TrimSpace(strings.TrimPrefix(content, "gitdir:"))
	return filepath.Abs(filepath.Join(gitRoot, gitDir))
}

func appendGitIgnoreBlock(gitDir, runID string, paths []string) (string, error) {
	infoDir := filepath.Join(gitDir, "info")
	excludePath := filepath.Join(infoDir, "exclude")

	if err := os.MkdirAll(infoDir, 0o750); err != nil {
		return "", err
	}

	blockStart := fmt.Sprintf("# confik:start:%s", runID)
	blockEnd := fmt.Sprintf("# confik:end:%s", runID)

	existing := ""
	// #nosec G304 -- excludePath is derived from resolved git dir.
	if data, err := os.ReadFile(excludePath); err == nil {
		existing = string(data)
		if strings.Contains(existing, blockStart) {
			return excludePath, nil
		}
	}

	lines := append([]string{blockStart}, paths...)
	lines = append(lines, blockEnd)
	block := strings.Join(lines, "\n") + "\n"

	if existing != "" && !strings.HasSuffix(existing, "\n") {
		existing += "\n"
	}

	return excludePath, os.WriteFile(excludePath, []byte(existing+block), 0o600)
}

func removeGitIgnoreBlock(excludePath, runID string) error {
	// #nosec G304 -- excludePath comes from git context generated by this tool.
	data, err := os.ReadFile(excludePath)
	if err != nil {
		return nil
	}

	updated := removeGitIgnoreBlocks(string(data), runID)
	if updated == string(data) {
		return nil
	}

	return os.WriteFile(excludePath, []byte(updated), 0o600)
}

func removeAllGitIgnoreBlocks(excludePath string) error {
	// #nosec G304 -- excludePath comes from resolved git dir for current workspace.
	data, err := os.ReadFile(excludePath)
	if err != nil {
		return nil
	}

	updated := removeGitIgnoreBlocks(string(data), "")
	if updated == string(data) {
		return nil
	}

	return os.WriteFile(excludePath, []byte(updated), 0o600)
}

func removeGitIgnoreBlocks(content, runID string) string {
	lines := strings.Split(content, "\n")
	out := []string{}
	skipping := false
	targetStart := ""
	targetEnd := ""
	if runID != "" {
		targetStart = fmt.Sprintf("# confik:start:%s", runID)
		targetEnd = fmt.Sprintf("# confik:end:%s", runID)
	}

	for _, line := range lines {
		if strings.HasPrefix(line, "# confik:start:") {
			if runID == "" || line == targetStart {
				skipping = true
				continue
			}
		}
		if skipping {
			if strings.HasPrefix(line, "# confik:end:") {
				if runID == "" || line == targetEnd {
					skipping = false
					continue
				}
			}
			continue
		}
		out = append(out, line)
	}

	result := strings.Join(out, "\n")
	if strings.HasSuffix(content, "\n") && !strings.HasSuffix(result, "\n") {
		result += "\n"
	}
	return result
}
